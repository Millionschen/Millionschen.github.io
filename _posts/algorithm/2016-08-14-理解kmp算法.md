---
layout: post
title: 理解kmp算法
category: 算法
tags: Essay
---

# 0 概述

字符串是编程中常用的一种数据结构，在各个方面都有广泛的应用，而字符串的一种基本操作就是给定一段长度为N的文本，而后给定一段长度M的pattern字符串，在文本中找到和该模式相同的子字符串。

>模式 -> N E E D L E
>
>文本 -> I N A H A Y S T A C K **N E E D L E** I N A

解决这个问题有一种简单的方法：

1. 从文本的第一个字符开始，逐一的与模式字符串的每个字符进行比较，如果找到符合的，查找结束
2. 在某个位置失配，则从文本的下一个字符串开始重复步骤1的操作

这种方法在大多数情况下都能良好的工作，然而在一些极端情况下运行时间可能会和MN成正比，如:

>模式 -> A A A A B
>
>文本 -> A A A A A A A A A A A A A A A A B

为了解决这个问题，Knuth， Morris和Pratt发明了一种快速查找子字符串的算法，保证最坏情况下运行时间为O(N), 这种算法被称为KMP算法。

# 1 KMP算法

# 1.1 基本思想

该算法的基本思想是，当出现不匹配当字符串时，我们已经知晓了一部分文本当内容，我们可以通过这部分信息减少比较的次数，如当字母表中只有两个字符A,B时:

>模式 -> B A A A A A B

当在第六个字符位置匹配失败，那么我们肯定可以知道文本当前六个字符是B A A A A B，那么我们无需再从第二个字符比起，而是可以从文本的第7个字符开始，与模式的2到7个字符比较，如果其7-13个字符是A A A A A B，则找到了符合模式的子字符串。

# 1.2 DFA数组

由1.1中的讨论可知当发生失配时，我们无需回退指向文本位置的指针i，而是需要确定应该从模式的第几个字符开始与文本的第i+1以及之后的若干个字符比较(假如从模式的位置j，则需要比较i+1到i+1+M-j),为了此需求，我们引入一个二维数组DFA[][]。

DFA[txt.charAt(i)][j]的含义为，当比较了文本当第i个字符与模式的第j个字符后，应当和txt.charAt(i+1)字符比较的模式字符位置，注意dfa[pat.charAt(j)][j]的值总是为j+1。

# 1.3 匹配算法

如果已经构造出了DFA矩阵，则在文本中查找模式的方法为:

```java
public int search(String txt) {
	int i,j,N=txt.length(),M=pat.length();
	for(int i = 0, j = 0; i < N && j < M; i++) {
		j = dfa[txt.charAt(i)][j];	
	}
	if (M == j) {
		return i-M;
	}
	return N;
}
```

这其实是一个有限状态自动机(图片来源为算法 第四版)：

![对于kmp算法的描述](http://ethanatos.qiniudn.com/WJAHIC%7BHIIUMK9L%25L%602TFVU.png)



那么该算法的关键就是如何构建dfa[][]数组了。

# 1.4 构建dfa[][]数组

**最关键的地方是:**假设在j处匹配失败，我们需要回退文本指针重新和模式进行一一对比，那么我们已知的需要重新扫描的文本字符就是pat.charAt(1)到pat.charAt(j-1)的。忽略首字母是因为文本右移了一位，忽略第j位是因为这一位失配了，我们不能通过模式确定文本中对应第字符是什么。那么对这些已知的文本字符进行DFA状态转换的话就可以知道当在j处失配的话应当将模式的指针回退到什么位置了。比如，对于模式A B A B A C，当j等于5时匹配失败，可以知道对B A B A进行匹配会使DFA进入状态3，就可以用dfa[pat.charAt(j)][3]计算出此时应当和txt.charAt(i+1)比较的模式指针的位置，因此对于失败对情况,dfa[][5]就应该等于dfa[][3]，对于成功的情况则由dfa[pat.charAt(j)][j]=j+1可以得知其值为j+1。

而对模式进行匹配对方法与search函数相同，所以从X=0开始，对于pat的位置j，要知道pat的下一个匹配情况只需要用X=dfa[pat.charAt(j)][X]就能计算出来了，对于dfa[][0],则明显有dfa[pat.charAt(0)][0]=1而其他值为0，这样就能通过递推算出整个dfa的值.

代码为:

```java
dfa[pat.charAt(0)][0] = 1;
for(int X = 0, j = 1; j < M; j++) {
	for (int c = 0; c < R; c++) {
		dfa[c][j] = dfa[c][X];
	}
	dfa[pat.charAt(j)][j] = j+1;
	X = dfa[pat.charAt(j)][X];
}
```

# 1.5 增强的kmp算法
上面的算法有一个问题:当R很大时(R为字符集的字符总数),额外空间MR很大，为了解决这个问题，我们将对这个算法进行一些改进。

我们注意到，之所以可以快速的定位j的新位置，是由于模式字符串已匹配的部分的开头和结尾有若干个字符互相匹配，这时可以将模式指针回退到前缀字符串的后一位。

```java
int[] makeNext(String pat)
{
    int q,k;//q:模版字符串下标；k:最大前后缀长度
    int m = pat.length;//模版字符串长度
	int[] next = new int[pat.length];
    next[0] = 0;//模版字符串的第一个字符的最大前后缀长度为0
    for (q = 1,k = 0; q < m; ++q)//for循环，从第二个字符开始，依次计算每一个字符对应的next值
    {
        while(k > 0 && pat.charAt(q) != pat.charAt(k))//递归的求出P[0]···P[q]的最大的相同的前后缀长度k
            k = next[k-1];          //这个while循环是整段代码的精髓所在
        if (pat[q] == pat[k])//如果相等，那么最大相同前后缀长度加1
        {
            k++;
        }
        next[q] = k;
    }
}
```

解释一下上面到代码，q代表当前已经计算到模板的第q个位置，k为位置q之前第最大前后缀长度。

那么当第k+1个字符与第q个字符相等时，我们就可以确定当前位置的最大前后缀长度应当为k+1.

然而，当第k+1个字符与第q个字符不相等时，应该如何处理呢？我们知道此时pat.charAt(k)已经和pat.charAt(q)失配了，而且pat.charAt(q-k) ··· pat.charAt(q-1)又与pat.charAt(0) ···pat.charAt(k-1)相同,那么我们如果我们能找到0到k-1内的最大前后缀字符串，这个字符串肯定也是q-k到q-1的最后一段，此时我们就可以继续看看这个字符串的后面一个字符是否和pat.charAt(q)相同了，如果不相同，则可以继续重复这个步骤。

得到next数组后，匹配的过程就很简单了:

如果匹配到文本到某个位置i的时候失配了，此时的模式指针值为j,那么从next就能读出此时的最长前后缀长度，也即是下一个比较的j的值(j应该在最长前缀子串的后面一位, 因为数组下标从0开始，所以两者正好相同),如下图：

![说明](http://ethanatos.qiniudn.com/bg2013050106.png)

这里在j=6处失配,next[5]为2，所以将j改为2


![说明2](http://ethanatos.qiniudn.com/bg2013050110.png)

这里在j=2处失配，next[1]为0，所以j改为0

![说明3](http://ethanatos.qiniudn.com/bg2013050111.png)

这里j为0时就不匹配,需要将i加1

重复以上步骤就能找到相应的子字符串