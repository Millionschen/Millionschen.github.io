---
layout: post
title: 理解红黑树
category: 算法
tags: Essay
---

# 理解红黑树

## 前言

红黑树是BST(binary search tree)的一种，现在常用的红黑树于1978年由 Guibas 和 Sedgewick 发明， 是[2-3-4树](https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree)的一种抽象表示。但是有趣的是，现在讲解算法的书籍很少提起**2-3-4树**与**红黑树**之间的关系，往往从定义出发讲解红黑树，而不提这些定义是怎么来的，这就是为何红黑树难以理解的原因。本文就从2-3-4树开始，逐步解释红黑树的定义与一些操作。

## 2-3-4树

### 2-3-4树的定义

2-3-4树也是一种有序的平衡树，所有从 leaf 到 root 的 path 的高度都是相等的。每个节点可以容纳1到3个节点，从而可以有最多4个子节点，下面是三种2-3-4树：

						                 B               D   F                H   K   O  
				                    	/ \             /  |  \              /  /   \   \  
				   	                   A   C           B   E   G            A  I     L   Y  
				                        2树                3树                    4树

类似BST， 2-3-4对元素的排序是左小右大。两个子节点之间的子树上的所有节点的值大于左子节点小于右子节点。比如上图的3树中的 E 就比 D 大 比 F 小。4树中的 I 比 H 大，比 K 小。

### 2-3-4树的插入

前面说了 2-3-4树是一种平横树，所有从 leaf 到 root 的 path 的高度都是相等的。这也就意味着每当插入一个新节点不能单纯的像 BST 那样将新的节点插入到树的底部，否则会破坏树的平衡。2-3-4树使用的平衡方法是合并。就是将2树变为3树，3树变4树。如下图：


								
								      B                          B
								     / \        插入 D =>       /  \
								    A   C                     A   C,D  
								                                  
								      B                          B
								    /   \       插入 H =>       /   \
								   A    C,D                    A  C,D,H


那么当一个节点上的值超过3个时，要插入新的数据应该如何处理呢？可以将4树往上挪一个节点，并分裂出俩个2树的子节点。如果上面的父节点已经是4树了，则继续往上挪动。直到 root 节点，再需要分裂的话，这个时候可以将 root 节点也进行分裂。root 节点分裂后整颗树的高度会增加一层。与BST不同，这是一种自下向上的生长方法。如下图所示：

  		   A                    A  S                      A   E   S          
 		  / \       插入 S=>   /  |  \       =>插入 E     /  /   \   \          => 插入 R ---->
   
		  
		先将 A E S 往上分裂  =>      E                                   E
                                  /  \          然后插入 R=>           /  \
                                 A    S                              A   R,S	


### 2-3-4树的删除

树结构的删除都很复杂，2-3-4树也不例外。注意，2-3-4树插入的时候需要保持树的平衡，删除的时候也需要保持树的平衡。不过作为一种有序树，删除任意节点都可以转换为删除值大于该节点的最小节点，所以我们先研究deleteMin操作如何实现。由于deleteMin操作的是叶子节点，当叶子节点是3-节点或4-节点时，我们可以直接删除子节点，这样不会影响树的平衡性：
			
			
					   C                   C                    D                     D
			     	  /     删除 B=>       /                    /       删除 B =>     /
			       	A，B                  A                  A，B，C                A，C

			
那么，如果叶子节点的子节点个数只有一个应该怎么处理才能保持树的平衡性呢？答案是沿着左链接向下进行变换，确保当前节点不是2-节点，而是一个3-节点或者4-节点：

1. 如果当前节点的左子节点不是2-节点，则什么也不用做

2. 当根结点，左结点，右结点都是2-节点时，将它们合并为一个4-节点

		 B
		/ \	            合并为一个4-节点   A B C
	   A   C						    / |  | \

3. 如果当前节点的左子节点是2-节点，而他的兄弟节点不是2-子节点，则将其兄弟节点的一个键移动到左子节点中来
			
					 B                                                  C
				   /   \                          ===> 借一个          /   \
				  A   C,D,E                                          A,B  D,E

4. 如果子节点和它到亲兄弟节点都是2-节点，那么将父节点到一个键和两个子节点一起合并为一个4-节点，使父节点键到树木减少1

			B D E                                                     D  E
		   / |                                      ==> 合并         /   | 
		  A  C													  A,B,C

删除时持续该过程，直到到达含有最小键的叶子节点。

## 红黑树

因为2-3-4树难以编程实现，所以将其转换为红黑树来表示。2008年 Sedgewick 对红黑树进行了改进，并将此命名为 LLRBT(Left-leaning red–black tree 左倾红黑树)，红节点都在父节点的左边。LLRBT 相比1978年的红黑树要简单很多，实现的代码量也少很多，本文介绍的是 LLRBT， 实际是一种2-3树，本文将红节点表示为 **//**,于是一个3-节点可以表示为:

							  A B                   B             
							 / | \  <=红黑树表示=>  //   
					                     		  A       

这样，将红节点拉平，就成来一个3-节点。

### 插入

不同于2-3树，红黑树在插入时通过旋转来降低或者升高树的高度。2-3树每插入一个节点会对树自底向上进行调整(合并或分裂)，红黑树也是对应于2-3树进行同样的操作。

 		 在2树中插入一个节点：
    	 D  插入C=>    D
    	             //
    	            C                                                          
                                                         <===等同于3树===>    C D
    	                 C                       D                          / | \
    	 C 插入D=>         \\          左旋=>   //
        	 	             D                C
                     


		
		在一个双键树中插入一个新键
		
					      B                C                      C
					    // \              // \                  //  \
					   A                 B                     A
					  / \               /                     /

		新键最大:                       新键最小:            新键居中
		 
		新加一个红节点                   新加一个红节点       新加一个红节点           
				          B               C                      C
					    //  \\          //  \                  //  \
	 				   A     C         B                      A
					  / \   / \       //                     /  \\
                                     A                            B
 		都转为黑节点                左旋：                   左旋转后变为红色左连接
			 			 
                       B                 B                     C
				    /    \             // \\                 //
			       A      C           A     C               B
				  / \    / \                               // 
													      A
						       
							      链接颜色变黑			  再左旋一次
                                     B                      B
                                   /   \                  // \\
                                  A     C                A     C 
														  
                                                          链接颜色变黑
														     B
															/ \
														   A   C


### 删除

红黑树的删除方法非常复杂。删除任意一个节点，红黑树会像 BST 一样会从右树的最左边找到一个节点进行替换并删除。所以实现红黑树的关键一点就是要实现 DeleteMin 方法，与上文对2-3-4树的删除的分析相同，LLRBT 在查找要删除的节点时就要对树进行调整，生成3-节点或临时对4-节点，在删除后再恢复树对平衡性。

贴上代码: [LLRBT的实现代码](http://ethanatos.qiniudn.com//code/RedBlackBST.java)

关键步骤的说明:

		          //       <----因为树是向左边递归的，           /
    		     H              所以到 H 的链都是红的           H
     		    / \                                        // \\
       		   C   S          颜色反转，将红色向下传=>       C    S     
      		  /                                          /
     		 B                                          B
   			
			 这时如果 S 节点的left为红色，因为返回时只会对删除路径上的节点进行balance操作，为了保证LLRBT的性质，需要对其再做两次旋转
           		/                          /                        /
       		   H                          H                        P
      	     // \\                      // \\                    // \\
       		C    S       右旋S=>        C    P         左旋 H=>   H    S      
      	   /    //                    /      \\                //  
     	  B    P                     B         S              C
        		                                             /
          		                                            B

                                                      //
            再将颜色反转回来=>                          P
                                                    / \
                                                   H   S
                                                 //
                                                C
                                               /
                                              B     

这里的主要操作还是flipColors rotateLeft rotateRight， 可以达成2-3树删除的效果