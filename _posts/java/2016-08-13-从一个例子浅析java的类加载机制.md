---
layout: post
title: 从一个例子浅析java的类加载机制
category: java
tags: java
---

# 0 源起

平时使用一个java类我们通常都会import这个类，然后调用该类的各种方法或访问其类的成员变量。类编译后生成的字节码文件通常就处于环境变量CLASSPATH指定的位置，我们不用关心jvm是如何找到这个类的字节码文件的。然而在某些情况下，我们需要对类的字节码可能会在一个zip压缩文件中，在网络上的其他主机的硬盘中或者仅仅被存在内存中，又或者出于安全的考虑我们希望对class文件encode，在加载时进行安全性校验和decode操作，这个时候jvm对默认行为就已经不能满足我们对需求了，这个时候我们应该怎么办呢？这就需要先了解一下jvm加载class文件对机制了。

# 1 什么是类加载

所谓类加载指将类的class文件读入内存，并为之创建一个java.lang.Class的对象。

# 2 类加载器

类加载器就是负责加载所有的类，将其载入内存中，生成一个java.lang.Class实例。一旦一个类被加载到JVM中之后，就不会再次载入了。

![类加载器的级别](http://ethanatos.qiniudn.com/20160531161623426.jpg)

* 根类加载器（Bootstrap ClassLoader）：其负责加载Java的核心类，比如String、System这些类
* 拓展类加载器（Extension ClassLoader）：其负责加载JRE的拓展类库
* 系统类加载器（System ClassLoader）：其负责加载CLASSPATH环境变量所指定的JAR包和类路径
* 用户类加载器：用户自定义的加载器，以类加载器为父类

注意这里的父子关系并不是指继承关系，而是类加载器实例之间的关系。话不多说，上代码:

```java
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
			}
```

上述代码是加载一个类的过程：

1. 先查看是否已加载过
2. 如果没有加载过且有父加载器时，由父加载器进行加载
3. 由bootstrap加载器加载
4. 以上都没有找到则由findClass方法进行加载，注意该方法都默认实现为抛出`ClassNotFoundException`

这种机制称为父类委托，可以防止一个类被多个加载器加载，导致代码运行时出现问题。

知道了类加载的机制，我们就可以在这动动脑筋了，比如通过重写findClass方法，我们就可以用自己都方式返回一个Class对象：

```java
String path = "pathToClass";
ClassLoader loader = new ClassLoader() {
        @Override
          protected Class<?> findClass(String name) throws ClassNotFoundException {
                Class<?> clz;
                String className = "";
                try {
                    className = path + name
                            .substring(name.lastIndexOf('.') + 1) + ".class";
                    InputStream iStream = new FileInputStream(className);

                    byte[] b = new byte[iStream.available()];
                    iStream.read(b);
                    clz =  defineClass(name, b, 0, b.length);
                } catch (Exception e) {
                    throw new ClassNotFoundException(className);
                }
                if (null != clz) {
                    return clz;
                }
                throw new ClassNotFoundException(className);
            }
        };
```

这里假设有一个类叫`TestLoad`，该类有一个方法`public void sayHello()`,存在文件夹`pathToClass`中，则可以加载之并生成对象：

```java
Class<?> clz = loader.loadClass("loadClass.TestLoader");
Object myObj = clz.newInstance();
```

而后调用其`sayHello`方法:

```java
Method method = clz.getMethod("sayHello");
method.invoke(myObj);
```